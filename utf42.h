/**
 * @file utf42.h
 * @brief Compile-time polymorphic string literal selection across character encodings.
 *
 * This header provides a mechanism to define a single string literal and
 * retrieve it as a `std::basic_string_view` of a desired character type
 * (`char`, `wchar_t`, `char8_t`, `char16_t`, or `char32_t`) at compile time.
 *
 * The approach relies on the compiler to generate all encoding variants
 * of a string literal (via literal prefixes such as `L`, `u8`, `u`, and `U`)
 * and selects the appropriate one using `consteval` dispatch.
 *
 * This guarantees:
 * - Zero runtime overhead
 * - No heap allocation
 * - No UTF transcoding at runtime
 * - Full support for `\uXXXX` and `\UXXXXXXXX` escape sequences
 *
 * @warning The macro `make_poly_enc` must be used with a string literal.
 *          Passing non-literals results in undefined behavior.
 *
 * @note Requires C++20 or later due to usage of `char8_t`, concepts,
 *       and `consteval`.
 *
 * @copyright MIT License
 *
 * This file is part of utf42.
 * Copyright (c) 2025 Dante Doménech Martínez
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#pragma once

#include <string_view>
#include <type_traits>

/**
 * @brief Creates a compile-time polymorphic encoded string literal.
 *
 * This macro generates all standard character-encoded versions of the
 * provided string literal and selects the one matching `char_t`.
 *
 * @param char_t Desired character type (`char`, `wchar_t`, `char8_t`,
 *               `char16_t`, or `char32_t`).
 * @param lit A string literal.
 *
 * @return A `std::basic_string_view<char_t>` referring to the selected literal.
 */
#define make_poly_enc(char_t, lit) utf42::visit_poly_enc<char_t>( \
    utf42::poly_enc{ \
        lit, \
        L##lit, \
        u8##lit, \
        u##lit, \
        U##lit, \
    } \
)

/**
 * @brief Constructs a compile-time polymorphic encoded string literal view.
 *
 * This macro generates all standard character-encoded versions of the
 * provided string literal.
 *
 * @param char_t Desired character type (`char`, `wchar_t`, `char8_t`,
 *               `char16_t`, or `char32_t`).
 * @param lit A string literal.
 *
 * @return A `std::basic_string_view<char_t>` referring to the selected literal.
 */
#define cons_poly_enc(lit) utf42::poly_enc{ \
    lit, \
    L##lit, \
    u8##lit, \
    u##lit, \
    U##lit, \
}

namespace utf42 {
    /**
     * @brief Type trait that checks whether a type is a supported character type.
     *
     * Supported types are:
     * - `char`
     * - `wchar_t`
     * - `char8_t`
     * - `char16_t`
     * - `char32_t`
     *
     * @tparam T Type to check.
     */
    template<typename T>
    struct is_char : std::bool_constant<
                std::is_same_v<T, char> ||
                std::is_same_v<T, wchar_t> ||
                std::is_same_v<T, char8_t> ||
                std::is_same_v<T, char16_t> ||
                std::is_same_v<T, char32_t>
            > {
    };

    /**
     * @brief Convenience variable template for `is_char`.
     *
     * @tparam T Type to check.
     */
    template<typename T>
    inline constexpr bool is_char_v = is_char<T>::value;

    /**
     * @brief Concept constraining a type to a supported character type.
     *
     * @tparam T Type to check.
     */
    template<typename T>
    concept CharType = is_char_v<T>;

    /**
     * @brief Concept constraining a type to an integral type.
     *
     * @tparam T Type to check.
     */
    template<typename T>
    concept IntegralType = std::is_integral_v<T>;

    /**
     * @brief Container holding all character-encoded views of a string literal.
     *
     * Instances of this type are intended to be constructed only from
     * string literals. Each member corresponds to a distinct literal
     * encoding generated by the compiler.
     *
     * No ownership is taken; all views refer directly to static storage.
     */
    struct poly_enc {
        std::basic_string_view<char> TXT_CHAR; ///< Narrow character literal
        std::basic_string_view<wchar_t> TXT_CHAR_W; ///< Wide character literal
        std::basic_string_view<char8_t> TXT_CHAR_8; ///< UTF-8 character literal
        std::basic_string_view<char16_t> TXT_CHAR_16; ///< UTF-16 character literal
        std::basic_string_view<char32_t> TXT_CHAR_32; ///< UTF-32 character literal

        /**
         * @brief Constructs a polymorphic encoding container.
         *
         * @param txt_char     Narrow character string view.
         * @param txt_char_w   Wide character string view.
         * @param txt_char_8   UTF-8 string view.
         * @param txt_char_16  UTF-16 string view.
         * @param txt_char_32  UTF-32 string view.
         */
        constexpr poly_enc(
            const std::basic_string_view<char> txt_char,
            const std::basic_string_view<wchar_t> txt_char_w,
            const std::basic_string_view<char8_t> txt_char_8,
            const std::basic_string_view<char16_t> txt_char_16,
            const std::basic_string_view<char32_t> txt_char_32
        ) noexcept
            : TXT_CHAR(txt_char),
              TXT_CHAR_W(txt_char_w),
              TXT_CHAR_8(txt_char_8),
              TXT_CHAR_16(txt_char_16),
              TXT_CHAR_32(txt_char_32) {
        }

        /**
         * @brief Selects the appropriate encoded string view for a given character type.
         *
         * This function is evaluated at compile time and returns a
         * `std::basic_string_view<char_t>` referring to the correctly
         * encoded literal stored in the provided `poly_enc`.
         * Returns an empty string if the character type is not recognized.
         *
         * @tparam char_t Desired character type.
         *
         * @return A string view of the requested character type or char_t"".
         */
        template<CharType char_t>
        constexpr std::basic_string_view<char_t>
        visit() const noexcept {
            if constexpr (std::is_same_v<char_t, char>)
                return this->TXT_CHAR;
            else if constexpr (std::is_same_v<char_t, wchar_t>)
                return this->TXT_CHAR_W;
            else if constexpr (std::is_same_v<char_t, char8_t>)
                return this->TXT_CHAR_8;
            else if constexpr (std::is_same_v<char_t, char16_t>)
                return this->TXT_CHAR_16;
            else if constexpr (std::is_same_v<char_t, char32_t>)
                return this->TXT_CHAR_32;
            else
                return std::basic_string_view<char_t>();
        }
    };

    /**
     * @brief Selects the appropriate encoded string view for a given character type.
     *
     * This function is evaluated at compile time and returns a
     * `std::basic_string_view<char_t>` referring to the correctly
     * encoded literal stored in the provided `poly_enc`.
     *
     * @tparam char_t Desired character type.
     * @param oPolyEnv Polymorphic encoding container.
     *
     * @return A string view of the requested character type.
     */
    template<CharType char_t>
    consteval std::basic_string_view<char_t>
    visit_poly_enc(const poly_enc &oPolyEnv) {
        return oPolyEnv.visit<char_t>();
    }
} // namespace utf42
