/**
 * @mainpage
 *
 * \image html presentation.png "Compile-time polymorphic string literals in C++17/C++20"
 *
 * @section utf-42 üåê utf-42
 *
 * **Compile-time polymorphic string literals for modern C++**
 *
 * `utf-42` is a small, header-only C++ utility that allows you to define a string
 * **once** and obtain it as a `std::basic_string_view` of any character type
 * (`char`, `wchar_t`, `char8_t`, `char16_t`, `char32_t`) **entirely at compile time**.
 *
 * It achieves this by leveraging the compiler‚Äôs built-in handling of Unicode
 * string literal prefixes (`""`, `L""`, `u8""`, `u""`, `U""`) and selecting the
 * appropriate encoding using `consteval` dispatch.
 *
 * The result is **zero runtime overhead**, no heap allocation, and no runtime
 * Unicode transcoding.
 *
 * @section index2 üìö Index
 *
 * 1. \ref intro "üìñ Intoduction"
 *   1. \ref features "‚ú® Features"
 *   2. \ref motivation "‚ùì Motivation"
 *   3. \ref requirements "üì¶ Requirementss"
 *   4. \ref limitations "‚ö†Ô∏è Important Limitations"
 *   5. \ref philosophy "üß† Design Philosophy"
 * 2. \ref technical "üõ†Ô∏è Technical documentation"
 *   1. \ref usage "üöÄ Usage"
 *   2. \ref inclusion "üîó Inclusion in Your Project"
 * 3. \ref license "üìÑ License"
 */

/**
 * @page intro üìñ Intoduction
 *
 * This page describes an overview of the capacities and limitations of this project.
 *
 * ---
 *
 * @section features ‚ú® Features
 *
 * - ‚úÖ Single source of truth for string literals
 * - ‚úÖ Zero runtime cost
 * - ‚úÖ No heap allocation
 * - ‚úÖ No UTF transcoding at runtime
 * - ‚úÖ Full support for `\uXXXX` and `\UXXXXXXXX`
 * - ‚úÖ Works with custom character typedefs
 * - ‚úÖ Header-only
 * - ‚úÖ C++20 compliant
 * - ‚úÖ C++17 compliant (not all features)
 *
 * ---
 *
 * @section motivation ‚ùì Motivation
 *
 * C++ does not allow templating string literal prefixes:
 *
 * ```cpp
 * make_str<char16_t>("hello"); // ‚ùå impossible
 * ```
 *
 * This leads to duplicated literals like:
 * ```cpp
 * "hello"
 * u"hello"
 * U"hello"
 * ```
 *
 * `utf42` solves this by:
 * 1. Letting the compiler generate all encoded variants of a literal
 * 2. Selecting the correct one at compile time based on the requested character type
 *
 * ---
 *
 * @section requirements üì¶ Requirements
 *
 * - C++17 or later
 *     - if constexpr
 * - C++20 or later (if available defines extra features):
 *     - char8_t
 *     - consteval
 *     - Concepts
 * - Recommended UTF-8 encoded source files
 * - A compiler with proper Unicode literal support (GCC, Clang, MSVC)
 *
 * ---
 *
 * @section limitations ‚ö†Ô∏è Important limitations
 *
 * The macro `make_poly_enc(CharacterType, lit)` must be used with string literals only.
 * Any other input will result in undefined behavior.
 * - No runtime strings
 * - No dynamic encoding conversion
 * - No grapheme-cluster or text-shaping logic
 * - This library operates strictly at the **code-unit level**.
 *
 * Such as:
 * ```
 * make_poly_enc(char16_t, "OK");     // ‚úÖ valid
 * make_poly_enc(char16_t, someVar);  // ‚ùå undefined behavior
 * ```
 *
 * ---
 *
 * @section philosophy üß† Design philosophy
 *
 * - Header only library
 * - Let the compiler handle Unicode parsing
 * - Prefer compile-time work over runtime work
 * - Avoid unnecessary abstraction or dependencies
 * - Keep the API minimal, explicit, and fast
 *
 * Ideal use cases include:
 * - Logging systems
 * - Localization keys
 * - Cross-platform APIs
 * - Performance-critical code
 * - Compile-time configuration strings
 */

/**
 * @page technical üõ†Ô∏è Technical documentation
 *
 * This section explains how to use the project as well as how to install it.
 *
 * @section usage üöÄ Usage
 *
 * This section explains how to use the project.
 *
 * ---
 *
 * @subsection example1 Basic example 1
 *
 * Approach: **one time use** string literal.
 *
 * We use the macro `make_poly_enc(CharacterType, lit)`
 * to process the string literal and reencode on
 * compile time to the desired character type.
 * This proves particularly usefull when the
 * character type is a template parameter.
 *
 * ```cpp
 * #include <utf42/utf42.h>
 *
 * // Typedef of char32_t
 * using char42_t = char32_t;
 *
 * // Different encoding views
 * constexpr std::basic_string_view<char>     strv_a  = make_poly_enc(char,     "Hello World \U0001F600!");
 * constexpr std::basic_string_view<char8_t>  strv_8  = make_poly_enc(char8_t,  "Hello World \U0001F600!");
 * constexpr std::basic_string_view<char16_t> strv_16 = make_poly_enc(char16_t, "Hello World \U0001F600!");
 * constexpr std::basic_string_view<char32_t> strv_32 = make_poly_enc(char32_t, "Hello World \U0001F600!");
 * constexpr std::basic_string_view<char42_t> strv_42 = make_poly_enc(char42_t, "Hello World \U0001F600!");
 * ```
 *
 * All variables above refer to the same logical string, encoded differently
 * by the compiler.
 *
 * Converting back to UTF-8 (for display)
 *
 * ```cpp
 * std::string str_a  (strv_a);
 * std::string str_8  (char8_to_char(strv_8));
 * std::string str_16 (utf8::utf16to8(strv_16));
 * std::string str_32 (utf8::utf32to8(strv_32));
 * std::string str_42 (utf8::utf32to8(strv_42));
 * ```
 *
 * ‚ö†Ô∏è Conversion helpers such as utf8::utf16to8 come from external libraries
 * (utf8cpp, `#include <utf8cpp/utf8.h>`) and are not part of utf42.
 *
 * See [utfcpp documentation](https://github.com/nemtrif/utfcpp) for more information.
 *
 * ---
 *
 * @subsection example2 Basic example 2
 *
 * Approach: **multiple time use** string literal.
 *
 * We use an instance of `utf42::poly_enc` to store all
 * variants and recover later the desired variant.
 * The macro `cons_poly_enc(lit)` constructs the object
 * from a single string literal.
 *
 * ```cpp
 * #include <utf42/utf42.h>
 *
 * // Typedef of char32_t
 * using char42_t = char32_t;
 *
 * // Create all different encoding string views
 * constexpr utf42::poly_enc oText = cons_poly_enc("Hello World \U0001F600!");
 * ```
 *
 * The variable above refer to the same logical string, encoded differently
 * by the compiler.
 *
 * Converting back to UTF-8 (for display)
 *
 * ```cpp
 * // Re-encode everything to utf-8
 * std::string str_a(oText.TXT_CHAR);
 * std::string str_8(char8_to_char(oText.TXT_CHAR_8));
 * std::string str_16(utf8::utf16to8(oText.TXT_CHAR_16));
 * std::string str_32(utf8::utf32to8(oText.TXT_CHAR_32));
 * std::string str_42(utf8::utf32to8(oText.visit<char42_t>()));
 * ```
 *
 * It is possible to use the function template `template<CharType char_t>
 * constexpr std::basic_string_view<char_t>
 * utf42::poly_enc::visit() const noexcept`
 * to recover the data in template scenarios.
 *
 * ‚ö†Ô∏è Conversion helpers such as utf8::utf16to8 come from external libraries
 * (utf8cpp, `#include <utf8cpp/utf8.h>`) and are not part of utf42.
 *
 * See [utfcpp documentation](https://github.com/nemtrif/utfcpp) for more information.
 *
 * ---
 *
 * @subsection exoutput Output
 *
 * ```cpp
 * std::cout << "Original: " << str_a  << '\n';
 * std::cout << "utf-8:    " << str_8  << '\n';
 * std::cout << "utf-16:   " << str_16 << '\n';
 * std::cout << "utf-32:   " << str_32 << '\n';
 * std::cout << "utf-42:   " << str_42 << '\n';
 * ```
 *
 * **Display on the terminal:**
 * ```txt
 * Original: Hello World üòÄ!
 * utf-8:    Hello World üòÄ!
 * utf-16:   Hello World üòÄ!
 * utf-32:   Hello World üòÄ!
 * utf-42:   Hello World üòÄ!
 * ```
 *
 * **‚ö†Ô∏è Terminal encoding requirement**
 *
 * Your terminal MUST be configured to use UTF-8 for this particular example to
 * print the output correctly. The user may re-encode the text appropriately
 * or change the setup of the terminal.
 *
 * If the terminal encoding is not UTF-8:
 * - Unicode characters may appear as ?, ‚ñ°, or mojibake
 * - This is not a bug in utf42
 *
 * Common setups:
 * - Linux / macOS: UTF-8 by default
 * - Windows:
 *     - Use Windows Terminal, or
 *     - Run: `chcp 65001`
 *
 * ---
 *
 * @section inclusion üîó Inclusion in your project
 *
 * This section explains how to include this library in your project.
 *
 * @subsection copypaste Copy-pase inclusion
 *
 * Simply copy the header [utf42.h](./utf42.h) into your project.
 * No additional setup or configuration is required.
 *
 * @subsection cmakeinclusion Cmake inclusion
 *
 * You need the `FetchContent` package:
 * ```cmake
 * include(FetchContent)
 * ```
 *
 * For more details, see the [FetchContent documentation](https://cmake.org/cmake/help/latest/module/FetchContent.html).
 *
 * Then, copy the following code into your CMake file to fetch the `utf42` library:
 * ```cmake
 * # Fetch the utf42 library
 * FetchContent_Declare(
 *         utf42
 *         GIT_REPOSITORY https://github.com/dante19031999/utf42
 *         GIT_TAG master
 * )
 * FetchContent_MakeAvailable(utf42)
 * ```
 *
 * After fetching the library, link it with your target.
 * Use the following line in your CMake configuration:
 * ```cmake
 * target_link_libraries(mylib VISIBILITY utf42::utf42)
 * ```
 *
 * For more details, see the [target_link_libraries documentation](https://cmake.org/cmake/help/latest/command/target_link_libraries.html).
 */

/**
 * @page license üìÑ License
 *
 * @section licenses üìÑ License
 *
 * MIT License
 *
 * Copyright (c) 2025 Dante Dom√©nech Mart√≠nez
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
